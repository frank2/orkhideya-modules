#!/bin/bash

source orkhideya
ork_include if
ork_include iw
ork_include proc
ork_include stdlib

function qemu_label
{
   local _machine="$1"

   echo "qemu-$_machine"
   return 0
}

function qemu_root
{
   ork_configpath "qemu"
   return 0
}

function qemu_img_root
{
   ork_pathcat "$(qemu_root)" "$ORK_QEMU_IMG_PATH"
   return 0
}

function qemu_vm_root
{
   ork_pathcat "$(qemu_root)" "$ORK_QEMU_VM_PATH"
   return 0
}

function qemu_img_path
{
   local _image="$1"
   ork_pathcat "$(qemu_img_root)" "$(stdlib_pathify "$_image")"
   return $?
}

function qemu_vm_path
{
   local _vm="$1"
   ork_pathcat "$(qemu_vm_root)" "$(stdlib_pathify "$_vm")"
   return $?
}

function qemu_img_file
{
   local _image="$1" 
   echo "$(qemu_img_path "$_image")/image"
   return 0
}

function qemu_img_exists
{
   local _image="$1"
   test -r "$(qemu_img_file "$_image")"
   return $?
}

function qemu_img_fork
{
   local _image="$1"
   ! qemu_img_exists "$_image" && return 1

   local _args="${@:2}"

   local _image_file="$(qemu_img_file "$_image")"

   qemu-img create -f qcow2 -b "$_image_file" $_args
   [ "$?" != "0" ] && return 3
   return 0
}

function qemu_img_mount
{
   local _image="$1"
   ! qemu_img_exists "$_image" && return 1

   local _mount_label="mount-$_image"
   proc_label_exists "$_mount_label" && return 0

   local _next_block="$(cat /proc/partitions | grep -o 'nbd[[:digit:]]+' | sort -u -h -r | head -n2 | cut -b 4-)"
   if [ -z "$_next_block" ]; then _next_block="nbd0"; else _next_block="nbd$(($_next_block+1))"; fi

   local _image_file="$(qemu_img_file "$_image")"
   ! proc_label_spawn "$_mount_label" "qemu-nbd -c /dev/$_next_block "$_image_file"" && return 3
   return 0
}

function qemu_img_unmount
{
   local _image="$1"
   ! qemu_img_exists "$_image" && return 1

   local _mount_label="mount-$_image"
   ! proc_label_exists "$_mount_label" && return 0

   ! proc_label_kill "$_mount_label" && return 2
   return 0
}

function qemu_vm_boot_file
{
   local _vm="$1" 
   echo "$(qemu_vm_path "$_vm")/boot"
   return 0
}

function qemu_vm_shutdown_file
{
   local _vm="$1" 
   echo "$(qemu_vm_path "$_vm")/shutdown"
   return 0
}

function qemu_vm_exists
{
   local _vm="$1"
   test -x "$(qemu_vm_path "$_vm")"
   return $?
}

function qemu_vm_boot
{
   local _vm="$1"
   ! qemu_vm_exists "$_vm" && return 1

   local _label="$2"
   local _args="${@:3}"
   local _boot_file="$(stdlib_filesearch "$(qemu_vm_root)" "$(stdlib_pathify "$_vm")" "boot")"
   [ -z "$_boot_file" ] && return 2
   [ ! -x "$_boot_file" ] && return 3
   ! "$_boot_file" "$_label" $_args && return 4

   return 0
}

function qemu_vm_shutdown
{
   local _vm="$1"
   ! qemu_vm_exists "$_vm" && return 1

   local _label="$2"
   local _args="${@:3}"
   local _shutdown_file="$(stdlib_filesearch "$(qemu_vm_root)" "$(stdlib_pathify "$_vm")" "shutdown")"
   [ -z "$_shutdown_file" ] && return 2
   [ ! -x "$_shutdown_file" ] && return 3
   ! "$_shutdown_file" "$_label" $_args && return 4

   return 0
}

function qemu_vm_monitor
{
   local _vm="$1"
   ! qemu_vm_exists "$_vm" && return 1

   local _label="$2"
   ! proc_label_exists "$_label" && return 3

   local _args="${@:3}"

   # wait a few seconds to let the VM launch.
   sleep 5

   while proc_label_is_running "$_label"; do sleep 3; done
   ! qemu_vm_shutdown "$_vm" "$_label" $_args &>/dev/null && return 4 

   return 0
}

function qemu_arg_exists
{
   local _args="$1"
   local _arg="$2"

   test -n "$(echo "$_args" | egrep -o "([[:space:]]+-$_arg([[:space:]]+|,)|^-$_arg([[:space:]]+|,)|[[:space:]]+-$_arg\$)")"
   return $?
}

function qemu_arg_default
{
   local _args="$1"
   local _arg="$2"
   local _value="${@:3}"

   if ! qemu_arg_exists "$_args" "$_arg"; then
      if [ -z "$_value" ]; then echo "-$_arg"
      elif [ -n "$(echo "$_arg" | grep -o '[[:space:]]')" ]; then echo "-${_arg}${_value}"
      else echo "-$_arg "$_value""
      fi
   fi

   return 0
}

ORK_QEMU_IMG_PATH="img"
ORK_QEMU_VM_PATH="vm"
ORK_QEMU_VM_HOST="localhost"

ork_reconfigure "qemu"
